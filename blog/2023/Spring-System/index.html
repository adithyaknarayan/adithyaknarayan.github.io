<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Simulating Fabrics: A Spring Element Approach | Adithya Narayan </title> <meta name="author" content="Adithya Narayan"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://adithyaknarayan.github.io/blog/2023/Spring-System/"> <script src="/assets/js/theme.js?a5ca4084d3b81624bcfa01156dae2b8e"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Simulating Fabrics: A Spring Element Approach",
            "description": "",
            "published": "January 25, 2023",
            "authors": [
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Adithya</span> Narayan </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Simulating Fabrics: A Spring Element Approach</h1> <p></p> </d-title> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#introduction">Introduction</a> </div> <div> <a href="#spring-elements-and-fem">Spring Elements and FEM?</a> </div> <div> <a href="#establishing-notation-and-our-point-sets">Establishing notation and our point sets</a> </div> <div> <a href="#building-ses-for-images">Building SES for images</a> </div> </nav> </d-contents> <h1 id="introduction">Introduction</h1> <p class="text-justify">In the era of deep learning and data-driven approaches to computer vision, there’s a certain beauty to classical computer vision techniques. This post is about one such idea.</p> <p class="text-justify">Recently, as part of some work, I’d been exploring the idea of warping pixels in 2D images using 3D mesh information. As a part of this, I investigated using spring elements, a finite element method (FEM), to come up with a fast efficient solution. This technique is also used in computer graphics to simulate the movement of fabrics in 2D.</p> <p>Hence, I’ll be going over how I implemented this in Python. This will be much more barebones than the actual use-case and of course, the actual implementation; however, I still thought it was pretty cool! So here goes.</p> <h1 id="spring-elements-and-fem">Spring Elements and FEM?</h1> <p class="text-justify">Okay, so I’ve mentioned spring elements. But what are they? Taking a step back, what even are “elements” and where do they come from? Essentially, this term comes from the a popular method which is used to solve differential equations ranging from those in structual analysis for buildings to those in heat transfer and fluid flow. It’s essentially a numerical approach to solving contrained (having boundary conditions) partial differential equations in multiple (2-3) dimensions.</p> <p class="text-justify">Typically, this involves the creating of a “mesh” of some sort, discretizing the 2D space in an image and producing the numerical solution for some kind of metric on these discrete points considering that some of these points are constrained. The way that we discretize our space is what the “element” is. For instance, if we divide our space into mesh made of squares, we have square elements. In our case, we use triangular elements and solve for displacements along the vertices of these triangles.</p> <p class="text-justify">And finally, why do we call it “spring” elements? Well, once we’ve divided our space into triangular elements, we must ask ourselves an important question. How are the vertices related to one another? For instance, for a solid object, it might be a good idea to say that the vertices are rigid relative to one another. In other words, since the overall geometery of the object should not change, points are not allowed to move closer or father away from its neighbours. However, suppose you wanted to simulate a stretchy material (like most fabrics). In this case, we want points to be able to stretch away from each other, but still have a force pulling them back to it’s original position. This is exactly how springs work! They produce a restorative force proportional to the change in length of the spring (Hooke’s Law).</p> \[F_s = -k * \Delta x\] <p><img src="spring_fig.png" alt="Spring Figure" style="display:block; margin-left:auto; margin-right:auto"></p> <p><em>A triangle element system where the vertices are related by Hooke’s Law.</em></p> <h1 id="building-ses-for-images">Building SES for images</h1> <p>So, now we know what spring elements are. Let’s get into creating one for images. We’ll be taking a pretty basic example. We’ll start by taking a random clothing texture as below. I’ve taken one with a little bit of shadows on it so that we can actually see what happening as we build the system out.</p> <p><img src="sample_texture.jpg" alt="Sample Fabric"></p> <p>Now we’ll define an arbitrary set of constrained points. Of course, usually this corresponds to some sort of mask which will stay constant over time. However, for illustrative purposes, I’ve taken a sample ring which will move from the top-left corner of the texture to the center of it.</p> <table> <thead> <tr> <th style="text-align: center">\(I^t\)</th> <th style="text-align: center">\(I^{t+1}\)</th> </tr> </thead> <tbody> <tr> <td style="text-align: center"><img src="constrained_mask_initial.png" alt="Initial Mask"></td> <td style="text-align: center"><img src="constrained_mask_final.png" alt="Final Mask"></td> </tr> <tr> <td style="text-align: center"><img src="constrained_image_initial.png" alt="Initial Mask"></td> <td style="text-align: center"><img src="constrained_image_final.png" alt="Final Mask"></td> </tr> </tbody> </table> <p>As can be seen, we’ve copied over the texture within the ring from the top-left of the image to the center. Ideally, what we’d want is for the rest of the pixels in the image to move along with it; behaving like a fabric in the process.</p> <p class="text-justify">To do this, we have to do the following things in order.</p> <ol class="text-justify"> <li>Define the constrained points (which we’ll be using to move the mesh) and the unconstrained points (which we will be solving for).</li> <li>Dividing the image into a mesh of triangle elements.</li> <li>Select a force constant , create the matrix $K$ and compute the energy $E$ of the system.</li> <li>Assemble system into a linear equation of form $vKv^{T} = 0$(this is quite important for optimization).</li> <li>Solve for unknown points by subdividing the symmetric matrix we obtain from above.</li> <li>Interpolate for points inside each element using their barycentric coordinates ($B_{x,y}$).</li> </ol> <p class="text-justify">With these steps in mind, let’s get to building it out.</p> <h2 id="establishing-notation-and-our-point-sets">Establishing notation and our point sets</h2> <p>We begin by defining our constrained/free points along with some other notation for convenience.</p> \[\begin{aligned} F &amp;= \{\text{free vertices}\} \nonumber \\ H &amp;= \{\text{constrained non-boundary vertices}\} \nonumber \\ B &amp;= \{\text{constrained boundary vertices}\} \nonumber \\ C &amp;= H+B \nonumber \\ V &amp;= F+C \nonumber \\ S_{ab} &amp;= \{\text{spring going from vertex $a$ to $b$}\} \nonumber \\ P(V) &amp;= \text{current position of vertex V} \nonumber \\ P_{0}(V) &amp;= \text{initial position of vertex V} \nonumber \\ K_h &amp;= \text{spring constant for F-H and H-H connections} \nonumber \\ K_f &amp;= \text{spring constant for F-F connections} \nonumber \end{aligned}\] <p>To illustrate things, lets take a simple system as shown below. Here the points marked in <strong>blue</strong> define our <strong>constrained points</strong> and the points marked in <strong>red</strong> define the <strong>free points</strong> for which their initial point in $I^t$ needs to be solved for.</p> <table> <thead> <tr> <th style="text-align: center">Image Frame</th> <th style="text-align: center">Constrained Points (\(C\))</th> <th style="text-align: center">Free Points (\(F\))</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">\(I^t\)</td> <td style="text-align: center"><img src="constrained_image_initial_red.png" alt="Initial Mask"></td> <td style="text-align: center">THIS NEEDS TO BE SOLVED FOR</td> </tr> <tr> <td style="text-align: center">\(I^{t+1}\)</td> <td style="text-align: center"><img src="constrained_image_final_red.png" alt="Initial Mask"></td> <td style="text-align: center"><img src="free_image_final_blue.png" alt="Final Mask"></td> </tr> </tbody> </table> <blockquote class="prompt-info"> <p>Here, $F$ is selected as a random normal distribution of points in 2D space. I used a knob <code class="language-plaintext highlighter-rouge">n_frac</code> to control the fraction of free points we take to solve. Technically, we could solve for <strong>every</strong> free point, but that’s incredibly slow and inefficient (hence why we interpolate at the end). By using <code class="language-plaintext highlighter-rouge">n_frac</code>, we can take a conveniently small fraction of points that works for larger images (512/1025/etc) with small tradeoffs in warping quality.</p> </blockquote> <p>With these in mind we also define two convenience terms. If you were to take an arbitrary spring connecting two points ($S_{ab}$), we define $P(S_a)$ and $P(S_b)$ as the current positions of vertices $a$ and $b$ respectively.</p> \[\begin{aligned} P_{sa} &amp;= P(S_a) \nonumber \\ P_{sb} &amp;= P(S_b) \nonumber \end{aligned}\] <p>Another important thing to note here is the nature of the spring constants. We could as per the definitions above, take $K_h$ and $K_f$ as the spring constants as is and build a matrix with this. However, defining things this way is messy for two reasons. For one, deriving the energy term (and subsequently assembling it) becomes messy. And another would be the way the force vector on a vertex changes on adding additional points since I’ll be working with zero-length spring elements. For instance take the sample grid below.</p> <p><img src="K_norm.png" alt="K_Norm Figure"> <em>In this system an additional point $b$ is added between $a$ and $c$. If $K_s = K$ then the force on $a$ halves, which it should not.</em></p> <p>If we were to add another point $b$ between $a$ and $c$, we end up halving the force applied on point $a$ if we assume that the constant $K$ remains the same. To ensure that $F_{new} = F_{old}$, we must do two things. One, set the initial spring lengths to 1 (zero-spring assumption) and also divide the new spring constant $K_s$ by the updated initial length of the spring.</p> \[\begin{aligned} F_{old} &amp;= -K \nonumber \\ F_{new} &amp;= -Ks*1/2 \nonumber \\ K_s &amp;= K/(1/2) = 2K \nonumber \end{aligned}\] <p>Thus obtaining,</p> \[F_{old}=F_{new}=-K\] <p>Hence to avoid both the messy derivation later and to correctly maintain the force on a vertex, we generalize the above equation by nomalizing the spring constants by the initial distance between the vertices $l_0$.</p> \[\begin{aligned} l_0 &amp;= ||P_0(S_a) - P_0(S_b)|| \nonumber \\ K_s &amp;= \begin{cases} K_h/l_0, \text{if} \ (S_a,S_b) \in H \\ K_f/l_0, \text{otherwise} \end{cases} \nonumber \end{aligned}\] <h2 id="dividing-the-image-into-triangular-elements">Dividing the image into triangular elements</h2> <p class="text-justify">The next step involves creating the aforementioned “mesh”. We primarily use triangular elements because in 2D space, 3 points define the minimum number of points required to define an area in an image. This is later relevant for linearly interpolating the displacements for points inside each triangular element using their barycentric coordinates.</p> <p class="text-justify">There are a number of ways in which we can create this mesh. But the simplest of them involves using an approach called <a href="https://gwlucastrig.github.io/TinfourDocs/DelaunayIntro/index.html" rel="external nofollow noopener" target="_blank"><strong>Delaunay Triangulation</strong></a>. While this approach offers a number of benefits, few of the main perks are that it produces <strong>non-inverted</strong>, <strong>non-skinny</strong> triangles. These kinds of triangles are nice for us particularly because our approach tends to produce $C_1$ <a href="https://root.cern/TaligentDocs/TaligentOnline/DocumentRoot/1.0/Docs/books/GS/GS_68.html" rel="external nofollow noopener" target="_blank"><strong>discontinuities</strong></a> along the boundaries between triangles during linear interpolation. Skinny triangles increase the likelyhood of these occuring and are generally far less visually pleasing.</p> <p>Performing the triangulation is relatively simple. We use <code class="language-plaintext highlighter-rouge">scipy</code>’s <code class="language-plaintext highlighter-rouge">spatial</code> module to subdivide the image into triangles. One particular advantage of this (and the reason I prefer this over OpenCV’s implementation) is the convenience of being able to use <code class="language-plaintext highlighter-rouge">scipy.spatial.Delaunay</code>’s helper methods to get the barycentric coordinates of points inside each triangle (or <code class="language-plaintext highlighter-rouge">simplex</code> as per the <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Delaunay.html" rel="external nofollow noopener" target="_blank"><strong>documentation</strong></a>).</p> <p>Applying this to the image that we had setup in the previous section, we obtain a list of triangles that make up the connections between vertices defined by $V$.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">scipy.spatial</span> <span class="kn">import</span> <span class="n">Delaunay</span>
<span class="c1"># here we assume that points are defined
</span><span class="n">sc</span> <span class="o">=</span> <span class="nc">Delaunay</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="n">triangle_list</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">sc</span><span class="p">.</span><span class="n">simplices</span><span class="p">]</span>
</code></pre></div></div> <p>We can even visualize the triangular mesh. However, it does tend to look quite messy and depends quite a bit on the spacing and selection criterion for the free/constrained points.</p> <table> <thead> <tr> <th style="text-align: center">Image Frame</th> <th style="text-align: center">Overall Points (${C}+{F}$)</th> <th style="text-align: center">Triangulation</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">$I^{t+1}$</td> <td style="text-align: center"><img src="overall_image_final_green.png" alt="Initial Mask"></td> <td style="text-align: center"><img src="triangulation_vis.png" alt="Triangulation Vis"></td> </tr> </tbody> </table> <blockquote class="prompt-info"> <p>In this step remember to test the following two criteria to ensure you don’t end up with a bad triangulation.</p> <ol> <li>Verify that all points are <strong>inside at least 1 triangle</strong>.</li> <li>Ensure that there are no inversions in the triangle.</li> <li>Also <strong>DO NOT FORGET</strong> to seed the way the free points are picked. Otherwise you end up with slightly different triangulations every run which is not great.</li> </ol> </blockquote> <h2 id="selecting-a-force-constant-and-computing-energy-term">Selecting a force constant and computing energy term</h2> <p>To compute the energy, we begin by defining the spring constant $K_h$, $K_f$ and subsequently $K_s$. To do this, we first need to the set of all edges between vertices in the image (to define the springs in the system). We’ve already obtained the <code class="language-plaintext highlighter-rouge">triangle_list</code> from the previous section, and we can use a fairly strightforward trick to vectorize the process of getting all the springs.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">p_sa</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span><span class="n">triangle_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">p_sb</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">([</span><span class="n">triangle_list</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">:,:],</span><span class="n">triangle_list</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">2</span><span class="p">,:]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div> <p>The first line is pretty obvious, we’re concatenating all the triplets we get from <code class="language-plaintext highlighter-rouge">triangle_list</code> into and $N \times 2$ vector as shown below.</p> \[\begin{pmatrix} V_j \\ V_k \end{pmatrix} = \begin{pmatrix} \begin{pmatrix} x_{j0} &amp; y_{j0} \\ x_{j1} &amp; y_{j1} \\ x_{j2} &amp; y_{j2} \end{pmatrix} \\ \begin{pmatrix} x_{k0} &amp; y_{k0} \\ x_{k1} &amp; y_{k1} \\ x_{k2} &amp; y_{k2} \end{pmatrix} \end{pmatrix} \rightarrow \begin{pmatrix} x_{j0} &amp; y_{j0} \\ x_{j1} &amp; y_{j1} \\ x_{j2} &amp; y_{j2} \\ x_{k0} &amp; y_{k0} \\ x_{k1} &amp; y_{k1} \\ x_{k2} &amp; y_{k2} \end{pmatrix}\] <p>In the second part, we internally rotate every triplet by one element. Then we concatenate the resulting array of triplets into a $N \times 2$ vector just as before.</p> \[\begin{pmatrix} V^R_j \\ V^R_k \end{pmatrix} = \begin{pmatrix} \begin{pmatrix} x_{j1} &amp; y_{j1} \\ x_{j2} &amp; y_{j2} \\ x_{j0} &amp; y_{j0} \end{pmatrix} \\ \begin{pmatrix} x_{k1} &amp; y_{k1} \\ x_{k2} &amp; y_{k2} \\ x_{k0} &amp; y_{k0} \end{pmatrix} \end{pmatrix} \rightarrow \begin{pmatrix} x_{j1} &amp; y_{j1} \\ x_{j2} &amp; y_{j2} \\ x_{j0} &amp; y_{j0} \\ x_{k1} &amp; y_{k1} \\ x_{k2} &amp; y_{k2} \\ x_{k0} &amp; y_{k0} \end{pmatrix}\] <p>Now putting the two together and pairing them, we obtain the clockwise-oriented pairs that represent the verteces of every spring in the system.</p> \[(P_{sa}, P_{sb}) = \begin{pmatrix} (x_{j0},y_{j0}) &amp; (x_{j1},y_{j1}) \\ (x_{j1} , y_{j1}) &amp; (x_{j2} , y_{j2}) \\ (x_{j2} , y_{j2}) &amp; (x_{j0} , y_{j0}) \\ (x_{k0} , y_{k0}) &amp; (x_{k1} , y_{k1}) \\ (x_{k1} , y_{k1}) &amp; (x_{k2} , y_{k2}) \\ (x_{k2} , y_{k2}) &amp; (x_{k0} , y_{k0}) \\ \end{pmatrix}\] <p>Now that we’ve gotten the springs, we can finally compute $l_0$ and subsequently $K_s$ for the system.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="k">def</span> <span class="nf">asvoid</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Based on http://stackoverflow.com/a/16973510/190597 (Jaime, 2013-06)
    View the array as dtype np.void (bytes). The items along the last axis are
    viewed as one value. This allows comparisons to be performed on the entire row.
    </span><span class="sh">"""</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">ascontiguousarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="nf">issubdtype</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">floating</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s"> Care needs to be taken here since
        np.array([-0.]).view(np.void) != np.array([0.]).view(np.void)
        Adding 0. converts -0. to 0.
        </span><span class="sh">"""</span>
        <span class="n">arr</span> <span class="o">+=</span> <span class="mf">0.</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">dtype</span><span class="p">((</span><span class="n">np</span><span class="p">.</span><span class="n">void</span><span class="p">,</span> <span class="n">arr</span><span class="p">.</span><span class="n">dtype</span><span class="p">.</span><span class="n">itemsize</span> <span class="o">*</span> <span class="n">arr</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>

<span class="k">def</span> <span class="nf">inNd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="nf">asvoid</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="nf">asvoid</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">in1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">assume_unique</span><span class="p">)</span>

<span class="n">l0</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">p_sa</span><span class="o">-</span><span class="n">p_sb</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">K_h</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">K_f</span> <span class="o">=</span> <span class="mi">100</span>

<span class="c1"># h is the set of constrained points
</span><span class="n">sa_mask</span> <span class="o">=</span> <span class="nf">inNd</span><span class="p">(</span><span class="n">p_sa</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
<span class="n">sb_mask</span> <span class="o">=</span> <span class="nf">inNd</span><span class="p">(</span><span class="n">p_sb</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
<span class="n">sa_sb_in_constrained</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">logical_and</span><span class="p">(</span><span class="n">sa_mask</span><span class="p">,</span> <span class="n">sb_mask</span><span class="p">)</span>

<span class="c1"># obtain Ks
</span><span class="n">Ks</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">sa_sb_in_constrained</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">Ks</span><span class="p">[</span><span class="n">sa_sb_in_constrained</span><span class="p">]</span> <span class="o">=</span> <span class="n">K_h</span>
<span class="n">Ks</span><span class="p">[</span><span class="o">~</span><span class="n">sa_sb_in_constrained</span><span class="p">]</span> <span class="o">=</span> <span class="n">K_f</span>
<span class="n">Ks</span><span class="o">=</span><span class="n">Ks</span><span class="o">/</span><span class="n">l0</span>
</code></pre></div></div> <p>Now that we’ve obtained all of this, we can compute the energy term defined by,</p> \[E = \sum_{s \in S} K_s ||P_{sa}-P_{sb}||^2\] <p>In all fairness, computing the energy term here isn’t <strong>necessary</strong>. However, it does serve as a sanity check for later when we test out assembly approach. Since <strong>assembly</strong> simply refers to re-ordering the above equation before differentiating, the numerical value of the energy term $E$ must remain the same.</p> <h2 id="assembling-the-system-into-a-linear-equation">Assembling the system into a linear equation</h2> <p>Assembly is the next key stage in the process. While all ominous sounding, assembly referes to idea of rearraging the energy term above into a standard form.</p> \[\begin{aligned}[b] E &amp;= \sum_{s \in S} K_s ||P_{sa}-P_{sb}||^2 \\ &amp;= d_s \times K_s \times d_s \\ &amp;= (P_{sa}-P_{sb}) \times K_s \times (P_{sa}-P_{sb}) \\ &amp;= P_{sa}K_sP_{sa} - P_{sa}K_sP_{sb} - P_{sa}K_sP_{sb} + P_{sb}K_sP_{sb} \\ &amp;= v \times K \times v^T \end{aligned}\] <p>For instance here, the process of converting the expansion of the energy term $E$ into the template of $vKv^T$ is known as assembly. While in theory this is a fairly straightforward process, implementing it in python turns out to be a pain in the neck. To begin with, implementing this as a loop ends up with the process taking over <strong>5 minutes</strong> per image!</p> <p>The process of converting the energy term into $vKv^T$ involves two parts.</p> <ol> <li>Generating $v$ which is the set of all unique vertices ({x,y} coordinates) we obtain from $P_{sa}$ <strong>and</strong> $P_{sb}$ and group them into free/constrained points.</li> <li>Generating $K$, which is the assembled version of $K_s$ created by inspecting $v$ and $v^T$.</li> </ol> <h3 id="generating-and-assembled-k-and-why-it-matters-to-grouping-v">Generating and assembled $K$ and why it matters to grouping $v$</h3> <p>While I would usually start with the first part, explaining the second part is key in understanding our objective. In the derivation above, we expanded the energy term as follows,</p> \[E = P_{sa}K_sP_{sa} - P_{sa}K_sP_{sb} - P_{sb}K_sP_{sa} + P_{sb}K_sP_{sb}\] <p>What we essentailly want to do, is to re-express this into an easily differentiable form $vKv^T$. Additionally, we want $v$ and $K$ to be set up in such a way that $v$ can be seperated into a constrained vector $C$ and a free vector $F$. Similarly, $K$ should also be easily seperable into a free matrix $K_f$ and a contrained matrix $K_c$. A good way to do that is to set up the vectors/matrices as shown below. <img src="K_seperable.png" alt="K Seperable"></p> <p><em>As can be seen, grouping $V$ and $K_s$ in this way allows us to easily seperate them into free and constrained parts. This makes solving for the free points easier.</em></p> <p>So to do this, we follow the two steps that I had mentioned above. However, let’s inspect the assembly step since this step influences how we group and make the unique vector $v$. To start, assume we already have $v$; a unique set of the shape $N \times 2$ (since 2D space). What we want to do, is for each pair from the expansion of $E$, find the corresponding entry in $K_s$. To illustrate this, let’s take the first term in $P_{sa}K_sP_{sa}$.</p> <p><img src="K_assembly_t1.png" alt="Term 1 Expansion"> <em>We find the corresponding positions of the spring in K by finding the index mapping between $P_{sa}$ and $v$.</em></p> <p>The first term as can be seen above is relatively simple. Since the term is $P_{sa}K_sP_{sa}$ any spring pair that we select between $P_sa$ and itself would point to the same coordinate. Hence, if we took three springs (spring 1, spring 2 and spring 3) which correcpond to the pairings $(v_1,v_1),(v_2, v_2) and (v_3, v_3)$ respectively between $P_{sa}$ and $P_{sa}$, we can take the value corresponding to the indices of these points and find them in $K_s$. In this case, it points to $K_{11}$, $K_{33}$ and $K_{33}$.</p> <blockquote class="prompt-info"> <p>Note that for the terms $P_{sa}K_sP_{sa}$ and $P_{sb}K_sP_{sb}$, it is infact <strong>impossible</strong> for it to index non-diagonal elements since both sides of K have the same vector.</p> </blockquote> <p>We now take these points and copy it to the positions indexed by the same points in $v$. This is visualized by the second part of the figure, where the positions of the springs have changed (as a consequence of being grouped), and hence the places where $K_{ii}$ have been copied to have been changed as well. Note the here, it <strong>still stays on the diagonal</strong>.</p> <p>A similar process is observed for the second and third terms of $E$ however. To illustrate, let’s take the second term $P_{sa}K_sP_{sb}$ for example. Since the indices of points are different between $P_{sa}$ and $P_{sb}$. Hence for spring 1,2 and 3, the points that are sample in $P_{sa}$ would be $(v_1,v_2,v_3)$. However, the points we sample from $P_{sb}$ would be $(v_4, v_5, v_6)$ and are <strong>NOT</strong> the same.</p> <p><img src="K_assembly_t2.png" alt="Term 2 Expansion"></p> <p>As can be seen, this begins to populate the <strong>non-diagonal</strong> elements of $K$ from $K_s$. Interestingly, the third term $P_{sb}K_sP_{sa}$ is exactly the same except the row and column indices would be flipped. Hence we also arrive at an important conclusion which will be an important sanity check later. The matrix $K$ <strong>must be symmetric along it’s major diagonal</strong>. You can see an example of that below (I most certainly did not find an excuse to add this figure because it looked like a dagger from a nostalgic era of 8-bit RPG’s).</p> <p><img src="sparse_k_vis.png" alt="Sparse K Visualized"></p> <p><em>Notice that here the matrix is symmetric along it’s major diagonal. Additionally, also notice that a majority of the entries are empty (hence its sparsity).</em></p> <blockquote class="prompt-info"> <p>Another important thing to note here is the sparsity of $K$. Since $P_{sa}$ and $P_{sb}$ only sample a small fraction of the points in a $H \times W$ image, the resulting points sampled in $K$ will also only be a fraction of the total dimensionality of the matrix. Hence, we will use the <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html" rel="external nofollow noopener" target="_blank">CSR representation</a> to store K.</p> </blockquote> <p>Now armed with all of this info, we can finally get some insight into how we want to group and assemble the vector $v$.</p> <ol> <li>We want the elements in v ordered in such a way that slicing it into <strong>free</strong> and <strong>constrained</strong> points is relatively simple.</li> <li>We want to perform this grouping operation with a focus on storing indices.</li> </ol> <p>The second point is particularly important. Since CSR representation mainly focuses on the data present at a particular row and column index, storing the indices as we find unique elements and group them, allow us to optimize how the <code class="language-plaintext highlighter-rouge">row</code> and <code class="language-plaintext highlighter-rouge">col</code> vector are generated.</p> <h3 id="grouping-and-creating-the-vector-v">Grouping and creating the vector $v$</h3> <p>So in general, as far as I could tell, there were 2 ways to go about doing the first part. However do note that the <strong>logic for the first approach was annoyingly complicated and not worth it</strong>.</p> <ol> <li>Group the points in $V$ and within each group identify the unique elements and build the sparse matrix K accordingly.</li> <li>Independently group $P_{sa}$ and $P_{sb}$. Then identify the unique points overall and generate the sparse matrix.</li> </ol> <p>For the first approach we first combine $P_{sa}$ and $P_{sb}$ into a single vector. Then the combined vector (as a whole) is grouped into the independent sets. For illustrative reasons, four are used below, but in our case, we simply group into three ($F$,$H$ and $B$). When we perform the grouping operation, the order of the elements in the vector are changed. Hence, we store <code class="language-plaintext highlighter-rouge">Original Index</code>, which serves as a pointer to the original position of the <code class="language-plaintext highlighter-rouge">Grouped Non-Unique</code> vector in <code class="language-plaintext highlighter-rouge">{P_sa}+{P_sb}</code> (two sets concatenated not added). Once this is done <code class="language-plaintext highlighter-rouge">np.unique</code> is used to find the unique elements <strong>within each group</strong>.</p> <p><img src="Approach2.png" alt="grouping_approach_1"> <em>The first approach illustrated. Here $F$, $G$, $B$ and $H$ represent arbitrary independent sets of points. Of course, in our application, it would only contain $F$,$H$ and $B$.</em></p> <p>This approach however, has a major flaw in the way the groups are formed. Since we combine $P_{sa}$ and $P_{sb}$ into a single vector, all points are repeated twice with two mappings in both <code class="language-plaintext highlighter-rouge">Inverse Index</code> as well as in <code class="language-plaintext highlighter-rouge">Original Index</code>. This ended up being a major hassle mapping back into the original vector (and subsequently $K_s$) and so was dropped.</p> <p>The second approach however, is far more straightforward. We find the unique elements for both $P_{sa}$ and $P_{sb}$ independently, but only use the unique vector generated from $P_sa$. This is essentially because ${P_{sa}} = {P_{sb}}$. Since they’re equal sets, we can simply search the elements to find the pointers from <code class="language-plaintext highlighter-rouge">np.unique(p_sb)</code> to <code class="language-plaintext highlighter-rouge">np.unique(p_sa)</code>.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">unique_vector</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">unique</span><span class="p">(</span><span class="n">p_sa</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">unique_vector</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">unique</span><span class="p">(</span><span class="n">p_sv</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">orig_indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">mat1</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">Ks</span><span class="p">[</span><span class="n">orig_indices</span><span class="p">]</span>
</code></pre></div></div> <p><img src="Approach3.png" alt="grouping_approach_1"></p> <p class="text-justify">Once the unique points are found, we group it; storing the backward lookup. Once this is done, we populate $K$ using the corresponding values from $K_s$.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">group_unique_vectors</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">unique_vector</span><span class="p">,</span> <span class="n">search_space_list</span><span class="p">):</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="p">{</span>
        <span class="sh">'</span><span class="s">points</span><span class="sh">'</span><span class="p">:[],</span>
        <span class="sh">'</span><span class="s">row</span><span class="sh">'</span><span class="p">:[],</span>
        <span class="sh">'</span><span class="s">col</span><span class="sh">'</span><span class="p">:[],</span>
        <span class="sh">'</span><span class="s">data</span><span class="sh">'</span><span class="p">:[],</span>
        <span class="sh">'</span><span class="s">group_length</span><span class="sh">'</span><span class="p">:[]</span>
    <span class="p">}</span>
    <span class="n">stacked_groups</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">index_list_assembled</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">unqiue_vector</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># get the updated mappings for the unique indices
</span>    <span class="n">index_list_grouped</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">search_space_list</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="nf">inNd</span><span class="p">(</span><span class="n">unique_vector</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span>
        <span class="n">index_list_selected</span> <span class="o">=</span> <span class="n">index_list_assembled</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">index_list_grouped</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">index_list_selected</span><span class="p">)</span>
        <span class="n">groups</span><span class="p">[</span><span class="sh">'</span><span class="s">points</span><span class="sh">'</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">unique_vector</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
        <span class="n">groups</span><span class="p">[</span><span class="sh">'</span><span class="s">group_length</span><span class="sh">'</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">unique_vector</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>

    <span class="c1"># create lookup for new indices
</span>    <span class="n">index_list_grouped</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span><span class="n">index_list_grouped</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">index_list_grouped</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">mapping</span><span class="p">[</span><span class="n">index_list_grouped</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_list_assembled</span>

    <span class="c1"># update row and column information with updated indices
</span>    <span class="n">row</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">row</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">col</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">groups</span><span class="p">[</span><span class="sh">'</span><span class="s">row</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>
    <span class="n">groups</span><span class="p">[</span><span class="sh">'</span><span class="s">col</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span>
    <span class="n">groups</span><span class="p">[</span><span class="sh">'</span><span class="s">data</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="c1"># update stacked stuff
</span>    <span class="n">stacked_groups</span><span class="p">[</span><span class="sh">'</span><span class="s">stacked_points</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span><span class="n">groups</span><span class="p">[</span><span class="sh">'</span><span class="s">points</span><span class="sh">'</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">stacked_groups</span><span class="p">[</span><span class="sh">'</span><span class="s">stacked_row</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>
    <span class="n">stacked_groups</span><span class="p">[</span><span class="sh">'</span><span class="s">stacked_col</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span>
    <span class="n">stacked_groups</span><span class="p">[</span><span class="sh">'</span><span class="s">stacked_data</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
    <span class="n">stacked_groups</span><span class="p">[</span><span class="sh">'</span><span class="s">stacked_group_length</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="sh">'</span><span class="s">group_length</span><span class="sh">'</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">groups</span><span class="p">,</span> <span class="n">stacked_groups</span>
</code></pre></div></div> <p>Once the assembly has been completed, we also <strong>verify the process</strong> by testing for the following equality.</p> \[VKV^T = \sum_{s \in S} K_s ||P_{sa}-P_{sb}||^2\] <h2 id="solving-for-free-points">Solving for free points</h2> <p>Perhaps the easiest step in all of this is solving for the free points in the system. Once we know where we’ll move the constrained points to, our job is to solve for the new position of free points. We take the assembled matrix $vKv^T$ from above and minimize the energy in the system.</p> \[\begin{aligned}[b] \frac{\partial E}{\partial V} &amp;= \frac{1}{2}K \times V = 0 \\ K \times V &amp;= 0 \\ K_f \times F + K_c \times C &amp;= 0 \\ K_f \times F &amp;= -K_c \times C \end{aligned}\] <p>Now that we have the free point positions $F$ in the above format, we can use any solver to solve for the matrix equation of the form $Ax = b$. In python, a good way to do this is to use the cg solver that scipy offers.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">cg</span>
<span class="n">known_b</span> <span class="o">=</span> <span class="n">K_c</span><span class="o">@</span><span class="p">(</span><span class="n">C</span><span class="o">-</span><span class="n">C_init</span><span class="p">)</span>
<span class="n">unknown_a</span> <span class="o">=</span> <span class="n">K_f</span>

<span class="c1"># solve for x and y
</span><span class="n">x_solved</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="nf">cg</span><span class="p">(</span><span class="n">unknown_a</span><span class="p">,</span> <span class="o">-</span><span class="n">known_b</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="n">y_solved</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="nf">cg</span><span class="p">(</span><span class="n">unknown_a</span><span class="p">,</span> <span class="o">-</span><span class="n">known_b</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="n">out_points</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">stack</span><span class="p">([</span><span class="n">x_solved</span><span class="p">,</span> <span class="n">y_solved</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div> <blockquote class="prompt-info"> <p>Note that the <code class="language-plaintext highlighter-rouge">maxiter=200</code> argument was set because it worked well in my particular case. You might need to play around with that to find the right number of iterations to solve for.</p> </blockquote> <p>Now that this is done, we know where the free points have moved to. All that’s left is the barycentric interpolation to interpolate for the points we didn’t solve for.</p> <h2 id="interpolating-the-points-inside-the-triangle">Interpolating the points inside the triangle</h2> <p>Now that we’ve assembled the matrix and solved for the free points $F$. We come to the final part, interpolating the intermediate values. As explained before, we create the free and constrained point triangulation at time $t+1$. Then we move the constrained points $C$ to the position it was at at $t$ and ask the question, where did $F$ move? Obtaining this gives us a warpfield that points from $F^{t+1}$ to $F^{t}$, in essence telling us <strong>where</strong> to sample the pixel values for image $I^{t+1}$ from image $I^{t}$.</p> <p>This results in us having the solution <strong>only</strong> at the vertices of the initial triangulation. To interpolate the pixel color values for $I^{t+1}$ at points within each triangle, we perform a piece-wise linear interpolation using the point’s <a href="https://en.wikipedia.org/wiki/Barycentric_coordinate_system#:~:text=In%20geometry%2C%20a%20barycentric%20coordinate,dimensional%20space%2C%20etc." rel="external nofollow noopener" target="_blank">barycentric coordinates</a>.</p> <p>To do this, we simply find the fractional distance between a random internal point to the vertices of the triangle. To understand this, let’s have a look at the system below. <img src="Barycentric_inter.png" alt="Barycentric Interpolation"></p> <p>Basically, we define the fractions, $a_1$, $a_2$ and $a_3$ as the following ratios.</p> \[\begin{aligned}[b] a1 = \frac{\text{Area of }\Delta P_3QP_2}{\text{Area of }\Delta P_1P_2P_3} \\ a2 = \frac{\text{Area of }\Delta P_1QP_3}{\text{Area of }\Delta P_1P_2P_3} \\ a3 = \frac{\text{Area of }\Delta P_1QP_2}{\text{Area of }\Delta P_1P_2P_3} \\ \end{aligned}\] <p>And then, the barycentric coordinates relative to the vertices would be,</p> \[Q = a_1P_1+a_2P_2+a_3P_3\] <p>With this, we can interpolate the pointers on a similar way. At each of the points defined by $F$, we have a $1 \times 2$ pointer that points to a sampling pixel from the $I^t$. Hence using the above equation, we can compute the pointer the coordinates in the triangles in $I^{t+1}$ must point to.</p> <p>Another way, which I prefer for neatness is to use the displacement field instead of the pointer field. The displacement field is simply the difference in value at coordinate $(i,j)$ with $(i,j)$. In essence,</p> \[\Delta(WF) = I^{t+1}(i,j) - (i,j)\] <p>Then a similar interpolation operation as mentioned above can be used to compute all the values. After which to restore it to a pointer field we simply perform,</p> \[WF_{inter} = \Delta(WF) + (i,j)\] <p>One particular reason I prefer this way is because it’s much easier to visualize the displacements as opposed to the pointers (which tend to look like a smooth gradient if done correctly).</p> <table> <thead> <tr> <th style="text-align: center">$I_t$</th> <th style="text-align: center">Post-Interpolation I^{t+1}</th> </tr> </thead> <tbody> <tr> <td style="text-align: center"><img src="constrained_image_initial_red.png" alt="Original Image"></td> <td style="text-align: center"><img src="warped_demo_image.png" alt="Warp Interpolation"></td> </tr> </tbody> </table> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Adithya Narayan. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>