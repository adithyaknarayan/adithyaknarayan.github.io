<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://adithyaknarayan.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://adithyaknarayan.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-04-23T15:12:22+00:00</updated><id>https://adithyaknarayan.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Simulating Fabrics: A Spring Element Approach</title><link href="https://adithyaknarayan.github.io/blog/2023/Spring-System/" rel="alternate" type="text/html" title="Simulating Fabrics: A Spring Element Approach"/><published>2023-01-25T00:00:00+00:00</published><updated>2023-01-25T00:00:00+00:00</updated><id>https://adithyaknarayan.github.io/blog/2023/Spring%20System</id><content type="html" xml:base="https://adithyaknarayan.github.io/blog/2023/Spring-System/"><![CDATA[<h1 id="introduction">Introduction</h1> <p class="text-justify">In the era of deep learning and data-driven approaches to computer vision, there’s a certain beauty to classical computer vision techniques. This post is about one such idea.</p> <p class="text-justify">Recently, as part of some work, I’d been exploring the idea of warping pixels in 2D images using 3D mesh information. As a part of this, I investigated using spring elements, a finite element method (FEM), to come up with a fast efficient solution. This technique is also used in computer graphics to simulate the movement of fabrics in 2D.</p> <p>Hence, I’ll be going over how I implemented this in Python. This will be much more barebones than the actual use-case and of course, the actual implementation; however, I still thought it was pretty cool! So here goes.</p> <h1 id="spring-elements-and-fem">Spring Elements and FEM?</h1> <p class="text-justify">Okay, so I’ve mentioned spring elements. But what are they? Taking a step back, what even are “elements” and where do they come from? Essentially, this term comes from the a popular method which is used to solve differential equations ranging from those in structual analysis for buildings to those in heat transfer and fluid flow. It’s essentially a numerical approach to solving contrained (having boundary conditions) partial differential equations in multiple (2-3) dimensions.</p> <p class="text-justify">Typically, this involves the creating of a “mesh” of some sort, discretizing the 2D space in an image and producing the numerical solution for some kind of metric on these discrete points considering that some of these points are constrained. The way that we discretize our space is what the “element” is. For instance, if we divide our space into mesh made of squares, we have square elements. In our case, we use triangular elements and solve for displacements along the vertices of these triangles.</p> <p class="text-justify">And finally, why do we call it “spring” elements? Well, once we’ve divided our space into triangular elements, we must ask ourselves an important question. How are the vertices related to one another? For instance, for a solid object, it might be a good idea to say that the vertices are rigid relative to one another. In other words, since the overall geometery of the object should not change, points are not allowed to move closer or father away from its neighbours. However, suppose you wanted to simulate a stretchy material (like most fabrics). In this case, we want points to be able to stretch away from each other, but still have a force pulling them back to it’s original position. This is exactly how springs work! They produce a restorative force proportional to the change in length of the spring (Hooke’s Law).</p> \[F_s = -k * \Delta x\] <p><img src="spring_fig.png" alt="Spring Figure"/> <em>A triangle element system where the vertices are related by Hooke’s Law.</em></p> <h1 id="building-ses-for-images">Building SES for images</h1> <p>So, now we know what spring elements are. Let’s get into creating one for images. We’ll be taking a pretty basic example. We’ll start by taking a random clothing texture as below. I’ve taken one with a little bit of shadows on it so that we can actually see what happening as we build the system out.</p> <p><img src="sample_texture.jpg" alt="Sample Fabric"/></p> <p>Now we’ll define an arbitrary set of constrained points. Of course, usually this corresponds to some sort of mask which will stay constant over time. However, for illustrative purposes, I’ve taken a sample ring which will move from the top-left corner of the texture to the center of it.</p> <table> <thead> <tr> <th style="text-align: center">\(I^t\)</th> <th style="text-align: center">\(I^{t+1}\)</th> </tr> </thead> <tbody> <tr> <td style="text-align: center"><img src="constrained_mask_initial.png" alt="Initial Mask"/></td> <td style="text-align: center"><img src="constrained_mask_final.png" alt="Final Mask"/></td> </tr> <tr> <td style="text-align: center"><img src="constrained_image_initial.png" alt="Initial Mask"/></td> <td style="text-align: center"><img src="constrained_image_final.png" alt="Final Mask"/></td> </tr> </tbody> </table> <p>As can be seen, we’ve copied over the texture within the ring from the top-left of the image to the center. Ideally, what we’d want is for the rest of the pixels in the image to move along with it; behaving like a fabric in the process.</p> <p class="text-justify">To do this, we have to do the following things in order.</p> <ol class="text-justify"> <li>Define the constrained points (which we’ll be using to move the mesh) and the unconstrained points (which we will be solving for).</li> <li>Dividing the image into a mesh of triangle elements.</li> <li>Select a force constant , create the matrix $K$ and compute the energy $E$ of the system.</li> <li>Assemble system into a linear equation of form $vKv^{T} = 0$(this is quite important for optimization).</li> <li>Solve for unknown points by subdividing the symmetric matrix we obtain from above.</li> <li>Interpolate for points inside each element using their barycentric coordinates ($B_{x,y}$).</li> </ol> <p class="text-justify">With these steps in mind, let’s get to building it out.</p> <h2 id="establishing-notation-and-our-point-sets">Establishing notation and our point sets</h2> <p>We begin by defining our constrained/free points along with some other notation for convenience.</p> \[\begin{aligned} F &amp;= \{\text{free vertices}\} \nonumber \\ H &amp;= \{\text{constrained non-boundary vertices}\} \nonumber \\ B &amp;= \{\text{constrained boundary vertices}\} \nonumber \\ C &amp;= H+B \nonumber \\ V &amp;= F+C \nonumber \\ S_{ab} &amp;= \{\text{spring going from vertex $a$ to $b$}\} \nonumber \\ P(V) &amp;= \text{current position of vertex V} \nonumber \\ P_{0}(V) &amp;= \text{initial position of vertex V} \nonumber \\ K_h &amp;= \text{spring constant for F-H and H-H connections} \nonumber \\ K_f &amp;= \text{spring constant for F-F connections} \nonumber \end{aligned}\] <p>To illustrate things, lets take a simple system as shown below. Here the points marked in <strong>blue</strong> define our <strong>constrained points</strong> and the points marked in <strong>red</strong> define the <strong>free points</strong> for which their initial point in $I^t$ needs to be solved for.</p> <table> <thead> <tr> <th style="text-align: center">Image Frame</th> <th style="text-align: center">Constrained Points (\(C\))</th> <th style="text-align: center">Free Points (\(F\))</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">\(I^t\)</td> <td style="text-align: center"><img src="constrained_image_initial_red.png" alt="Initial Mask"/></td> <td style="text-align: center">THIS NEEDS TO BE SOLVED FOR</td> </tr> <tr> <td style="text-align: center">\(I^{t+1}\)</td> <td style="text-align: center"><img src="constrained_image_final_red.png" alt="Initial Mask"/></td> <td style="text-align: center"><img src="free_image_final_blue.png" alt="Final Mask"/></td> </tr> </tbody> </table> <blockquote class="prompt-info"> <p>Here, $F$ is selected as a random normal distribution of points in 2D space. I used a knob <code class="language-plaintext highlighter-rouge">n_frac</code> to control the fraction of free points we take to solve. Technically, we could solve for <strong>every</strong> free point, but that’s incredibly slow and inefficient (hence why we interpolate at the end). By using <code class="language-plaintext highlighter-rouge">n_frac</code>, we can take a conveniently small fraction of points that works for larger images (512/1025/etc) with small tradeoffs in warping quality.</p> </blockquote> <p>With these in mind we also define two convenience terms. If you were to take an arbitrary spring connecting two points ($S_{ab}$), we define $P(S_a)$ and $P(S_b)$ as the current positions of vertices $a$ and $b$ respectively.</p> \[\begin{aligned} P_{sa} &amp;= P(S_a) \nonumber \\ P_{sb} &amp;= P(S_b) \nonumber \end{aligned}\] <p>Another important thing to note here is the nature of the spring constants. We could as per the definitions above, take $K_h$ and $K_f$ as the spring constants as is and build a matrix with this. However, defining things this way is messy for two reasons. For one, deriving the energy term (and subsequently assembling it) becomes messy. And another would be the way the force vector on a vertex changes on adding additional points since I’ll be working with zero-length spring elements. For instance take the sample grid below.</p> <p><img src="K_norm.png" alt="K_Norm Figure"/> <em>In this system an additional point $b$ is added between $a$ and $c$. If $K_s = K$ then the force on $a$ halves, which it should not.</em></p> <p>If we were to add another point $b$ between $a$ and $c$, we end up halving the force applied on point $a$ if we assume that the constant $K$ remains the same. To ensure that $F_{new} = F_{old}$, we must do two things. One, set the initial spring lengths to 1 (zero-spring assumption) and also divide the new spring constant $K_s$ by the updated initial length of the spring.</p> \[\begin{aligned} F_{old} &amp;= -K \nonumber \\ F_{new} &amp;= -Ks*1/2 \nonumber \\ K_s &amp;= K/(1/2) = 2K \nonumber \end{aligned}\] <p>Thus obtaining,</p> \[F_{old}=F_{new}=-K\] <p>Hence to avoid both the messy derivation later and to correctly maintain the force on a vertex, we generalize the above equation by nomalizing the spring constants by the initial distance between the vertices $l_0$.</p> \[\begin{aligned} l_0 &amp;= ||P_0(S_a) - P_0(S_b)|| \nonumber \\ K_s &amp;= \begin{cases} K_h/l_0, \text{if} \ (S_a,S_b) \in H \\ K_f/l_0, \text{otherwise} \end{cases} \nonumber \end{aligned}\] <h2 id="dividing-the-image-into-triangular-elements">Dividing the image into triangular elements</h2> <p class="text-justify">The next step involves creating the aforementioned “mesh”. We primarily use triangular elements because in 2D space, 3 points define the minimum number of points required to define an area in an image. This is later relevant for linearly interpolating the displacements for points inside each triangular element using their barycentric coordinates.</p> <p class="text-justify">There are a number of ways in which we can create this mesh. But the simplest of them involves using an approach called <a href="https://gwlucastrig.github.io/TinfourDocs/DelaunayIntro/index.html"><strong>Delaunay Triangulation</strong></a>. While this approach offers a number of benefits, few of the main perks are that it produces <strong>non-inverted</strong>, <strong>non-skinny</strong> triangles. These kinds of triangles are nice for us particularly because our approach tends to produce $C_1$ <a href="https://root.cern/TaligentDocs/TaligentOnline/DocumentRoot/1.0/Docs/books/GS/GS_68.html"><strong>discontinuities</strong></a> along the boundaries between triangles during linear interpolation. Skinny triangles increase the likelyhood of these occuring and are generally far less visually pleasing.</p> <p>Performing the triangulation is relatively simple. We use <code class="language-plaintext highlighter-rouge">scipy</code>’s <code class="language-plaintext highlighter-rouge">spatial</code> module to subdivide the image into triangles. One particular advantage of this (and the reason I prefer this over OpenCV’s implementation) is the convenience of being able to use <code class="language-plaintext highlighter-rouge">scipy.spatial.Delaunay</code>’s helper methods to get the barycentric coordinates of points inside each triangle (or <code class="language-plaintext highlighter-rouge">simplex</code> as per the <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Delaunay.html"><strong>documentation</strong></a>).</p> <p>Applying this to the image that we had setup in the previous section, we obtain a list of triangles that make up the connections between vertices defined by $V$.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">scipy.spatial</span> <span class="kn">import</span> <span class="n">Delaunay</span>
<span class="c1"># here we assume that points are defined
</span><span class="n">sc</span> <span class="o">=</span> <span class="nc">Delaunay</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="n">triangle_list</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">sc</span><span class="p">.</span><span class="n">simplices</span><span class="p">]</span>
</code></pre></div></div> <p>We can even visualize the triangular mesh. However, it does tend to look quite messy and depends quite a bit on the spacing and selection criterion for the free/constrained points.</p> <table> <thead> <tr> <th style="text-align: center">Image Frame</th> <th style="text-align: center">Overall Points (${C}+{F}$)</th> <th style="text-align: center">Triangulation</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">$I^{t+1}$</td> <td style="text-align: center"><img src="overall_image_final_green.png" alt="Initial Mask"/></td> <td style="text-align: center"><img src="triangulation_vis.png" alt="Triangulation Vis"/></td> </tr> </tbody> </table> <blockquote class="prompt-info"> <p>In this step remember to test the following two criteria to ensure you don’t end up with a bad triangulation.</p> <ol> <li>Verify that all points are <strong>inside at least 1 triangle</strong>.</li> <li>Ensure that there are no inversions in the triangle.</li> <li>Also <strong>DO NOT FORGET</strong> to seed the way the free points are picked. Otherwise you end up with slightly different triangulations every run which is not great.</li> </ol> </blockquote> <h2 id="selecting-a-force-constant-and-computing-energy-term">Selecting a force constant and computing energy term</h2> <p>To compute the energy, we begin by defining the spring constant $K_h$, $K_f$ and subsequently $K_s$. To do this, we first need to the set of all edges between vertices in the image (to define the springs in the system). We’ve already obtained the <code class="language-plaintext highlighter-rouge">triangle_list</code> from the previous section, and we can use a fairly strightforward trick to vectorize the process of getting all the springs.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">p_sa</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span><span class="n">triangle_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">p_sb</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">([</span><span class="n">triangle_list</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">:,:],</span><span class="n">triangle_list</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">2</span><span class="p">,:]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div> <p>The first line is pretty obvious, we’re concatenating all the triplets we get from <code class="language-plaintext highlighter-rouge">triangle_list</code> into and $N \times 2$ vector as shown below.</p> \[\begin{pmatrix} V_j \\ V_k \end{pmatrix} = \begin{pmatrix} \begin{pmatrix} x_{j0} &amp; y_{j0} \\ x_{j1} &amp; y_{j1} \\ x_{j2} &amp; y_{j2} \end{pmatrix} \\ \begin{pmatrix} x_{k0} &amp; y_{k0} \\ x_{k1} &amp; y_{k1} \\ x_{k2} &amp; y_{k2} \end{pmatrix} \end{pmatrix} \rightarrow \begin{pmatrix} x_{j0} &amp; y_{j0} \\ x_{j1} &amp; y_{j1} \\ x_{j2} &amp; y_{j2} \\ x_{k0} &amp; y_{k0} \\ x_{k1} &amp; y_{k1} \\ x_{k2} &amp; y_{k2} \end{pmatrix}\] <p>In the second part, we internally rotate every triplet by one element. Then we concatenate the resulting array of triplets into a $N \times 2$ vector just as before.</p> \[\begin{pmatrix} V^R_j \\ V^R_k \end{pmatrix} = \begin{pmatrix} \begin{pmatrix} x_{j1} &amp; y_{j1} \\ x_{j2} &amp; y_{j2} \\ x_{j0} &amp; y_{j0} \end{pmatrix} \\ \begin{pmatrix} x_{k1} &amp; y_{k1} \\ x_{k2} &amp; y_{k2} \\ x_{k0} &amp; y_{k0} \end{pmatrix} \end{pmatrix} \rightarrow \begin{pmatrix} x_{j1} &amp; y_{j1} \\ x_{j2} &amp; y_{j2} \\ x_{j0} &amp; y_{j0} \\ x_{k1} &amp; y_{k1} \\ x_{k2} &amp; y_{k2} \\ x_{k0} &amp; y_{k0} \end{pmatrix}\] <p>Now putting the two together and pairing them, we obtain the clockwise-oriented pairs that represent the verteces of every spring in the system.</p> \[(P_{sa}, P_{sb}) = \begin{pmatrix} (x_{j0},y_{j0}) &amp; (x_{j1},y_{j1}) \\ (x_{j1} , y_{j1}) &amp; (x_{j2} , y_{j2}) \\ (x_{j2} , y_{j2}) &amp; (x_{j0} , y_{j0}) \\ (x_{k0} , y_{k0}) &amp; (x_{k1} , y_{k1}) \\ (x_{k1} , y_{k1}) &amp; (x_{k2} , y_{k2}) \\ (x_{k2} , y_{k2}) &amp; (x_{k0} , y_{k0}) \\ \end{pmatrix}\] <p>Now that we’ve gotten the springs, we can finally compute $l_0$ and subsequently $K_s$ for the system.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="k">def</span> <span class="nf">asvoid</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Based on http://stackoverflow.com/a/16973510/190597 (Jaime, 2013-06)
    View the array as dtype np.void (bytes). The items along the last axis are
    viewed as one value. This allows comparisons to be performed on the entire row.
    </span><span class="sh">"""</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">ascontiguousarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="nf">issubdtype</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">floating</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s"> Care needs to be taken here since
        np.array([-0.]).view(np.void) != np.array([0.]).view(np.void)
        Adding 0. converts -0. to 0.
        </span><span class="sh">"""</span>
        <span class="n">arr</span> <span class="o">+=</span> <span class="mf">0.</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">dtype</span><span class="p">((</span><span class="n">np</span><span class="p">.</span><span class="n">void</span><span class="p">,</span> <span class="n">arr</span><span class="p">.</span><span class="n">dtype</span><span class="p">.</span><span class="n">itemsize</span> <span class="o">*</span> <span class="n">arr</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>

<span class="k">def</span> <span class="nf">inNd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="nf">asvoid</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="nf">asvoid</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">in1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">assume_unique</span><span class="p">)</span>

<span class="n">l0</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">p_sa</span><span class="o">-</span><span class="n">p_sb</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">K_h</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">K_f</span> <span class="o">=</span> <span class="mi">100</span>

<span class="c1"># h is the set of constrained points
</span><span class="n">sa_mask</span> <span class="o">=</span> <span class="nf">inNd</span><span class="p">(</span><span class="n">p_sa</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
<span class="n">sb_mask</span> <span class="o">=</span> <span class="nf">inNd</span><span class="p">(</span><span class="n">p_sb</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
<span class="n">sa_sb_in_constrained</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">logical_and</span><span class="p">(</span><span class="n">sa_mask</span><span class="p">,</span> <span class="n">sb_mask</span><span class="p">)</span>

<span class="c1"># obtain Ks
</span><span class="n">Ks</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">sa_sb_in_constrained</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">Ks</span><span class="p">[</span><span class="n">sa_sb_in_constrained</span><span class="p">]</span> <span class="o">=</span> <span class="n">K_h</span>
<span class="n">Ks</span><span class="p">[</span><span class="o">~</span><span class="n">sa_sb_in_constrained</span><span class="p">]</span> <span class="o">=</span> <span class="n">K_f</span>
<span class="n">Ks</span><span class="o">=</span><span class="n">Ks</span><span class="o">/</span><span class="n">l0</span>
</code></pre></div></div> <p>Now that we’ve obtained all of this, we can compute the energy term defined by,</p> \[E = \sum_{s \in S} K_s ||P_{sa}-P_{sb}||^2\] <p>In all fairness, computing the energy term here isn’t <strong>necessary</strong>. However, it does serve as a sanity check for later when we test out assembly approach. Since <strong>assembly</strong> simply refers to re-ordering the above equation before differentiating, the numerical value of the energy term $E$ must remain the same.</p> <h2 id="assembling-the-system-into-a-linear-equation">Assembling the system into a linear equation</h2> <p>Assembly is the next key stage in the process. While all ominous sounding, assembly referes to idea of rearraging the energy term above into a standard form.</p> \[\begin{aligned}[b] E &amp;= \sum_{s \in S} K_s ||P_{sa}-P_{sb}||^2 \\ &amp;= d_s \times K_s \times d_s \\ &amp;= (P_{sa}-P_{sb}) \times K_s \times (P_{sa}-P_{sb}) \\ &amp;= P_{sa}K_sP_{sa} - P_{sa}K_sP_{sb} - P_{sa}K_sP_{sb} + P_{sb}K_sP_{sb} \\ &amp;= v \times K \times v^T \end{aligned}\] <p>For instance here, the process of converting the expansion of the energy term $E$ into the template of $vKv^T$ is known as assembly. While in theory this is a fairly straightforward process, implementing it in python turns out to be a pain in the neck. To begin with, implementing this as a loop ends up with the process taking over <strong>5 minutes</strong> per image!</p> <p>The process of converting the energy term into $vKv^T$ involves two parts.</p> <ol> <li>Generating $v$ which is the set of all unique vertices ({x,y} coordinates) we obtain from $P_{sa}$ <strong>and</strong> $P_{sb}$ and group them into free/constrained points.</li> <li>Generating $K$, which is the assembled version of $K_s$ created by inspecting $v$ and $v^T$.</li> </ol> <h3 id="generating-and-assembled-k-and-why-it-matters-to-grouping-v">Generating and assembled $K$ and why it matters to grouping $v$</h3> <p>While I would usually start with the first part, explaining the second part is key in understanding our objective. In the derivation above, we expanded the energy term as follows,</p> \[E = P_{sa}K_sP_{sa} - P_{sa}K_sP_{sb} - P_{sb}K_sP_{sa} + P_{sb}K_sP_{sb}\] <p>What we essentailly want to do, is to re-express this into an easily differentiable form $vKv^T$. Additionally, we want $v$ and $K$ to be set up in such a way that $v$ can be seperated into a constrained vector $C$ and a free vector $F$. Similarly, $K$ should also be easily seperable into a free matrix $K_f$ and a contrained matrix $K_c$. A good way to do that is to set up the vectors/matrices as shown below. <img src="K_seperable.png" alt="K Seperable"/></p> <p><em>As can be seen, grouping $V$ and $K_s$ in this way allows us to easily seperate them into free and constrained parts. This makes solving for the free points easier.</em></p> <p>So to do this, we follow the two steps that I had mentioned above. However, let’s inspect the assembly step since this step influences how we group and make the unique vector $v$. To start, assume we already have $v$; a unique set of the shape $N \times 2$ (since 2D space). What we want to do, is for each pair from the expansion of $E$, find the corresponding entry in $K_s$. To illustrate this, let’s take the first term in $P_{sa}K_sP_{sa}$.</p> <p><img src="K_assembly_t1.png" alt="Term 1 Expansion"/> <em>We find the corresponding positions of the spring in K by finding the index mapping between $P_{sa}$ and $v$.</em></p> <p>The first term as can be seen above is relatively simple. Since the term is $P_{sa}K_sP_{sa}$ any spring pair that we select between $P_sa$ and itself would point to the same coordinate. Hence, if we took three springs (spring 1, spring 2 and spring 3) which correcpond to the pairings $(v_1,v_1),(v_2, v_2) and (v_3, v_3)$ respectively between $P_{sa}$ and $P_{sa}$, we can take the value corresponding to the indices of these points and find them in $K_s$. In this case, it points to $K_{11}$, $K_{33}$ and $K_{33}$.</p> <blockquote class="prompt-info"> <p>Note that for the terms $P_{sa}K_sP_{sa}$ and $P_{sb}K_sP_{sb}$, it is infact <strong>impossible</strong> for it to index non-diagonal elements since both sides of K have the same vector.</p> </blockquote> <p>We now take these points and copy it to the positions indexed by the same points in $v$. This is visualized by the second part of the figure, where the positions of the springs have changed (as a consequence of being grouped), and hence the places where $K_{ii}$ have been copied to have been changed as well. Note the here, it <strong>still stays on the diagonal</strong>.</p> <p>A similar process is observed for the second and third terms of $E$ however. To illustrate, let’s take the second term $P_{sa}K_sP_{sb}$ for example. Since the indices of points are different between $P_{sa}$ and $P_{sb}$. Hence for spring 1,2 and 3, the points that are sample in $P_{sa}$ would be $(v_1,v_2,v_3)$. However, the points we sample from $P_{sb}$ would be $(v_4, v_5, v_6)$ and are <strong>NOT</strong> the same.</p> <p><img src="K_assembly_t2.png" alt="Term 2 Expansion"/></p> <p>As can be seen, this begins to populate the <strong>non-diagonal</strong> elements of $K$ from $K_s$. Interestingly, the third term $P_{sb}K_sP_{sa}$ is exactly the same except the row and column indices would be flipped. Hence we also arrive at an important conclusion which will be an important sanity check later. The matrix $K$ <strong>must be symmetric along it’s major diagonal</strong>. You can see an example of that below (I most certainly did not find an excuse to add this figure because it looked like a dagger from a nostalgic era of 8-bit RPG’s).</p> <p><img src="sparse_k_vis.png" alt="Sparse K Visualized"/></p> <p><em>Notice that here the matrix is symmetric along it’s major diagonal. Additionally, also notice that a majority of the entries are empty (hence its sparsity).</em></p> <blockquote class="prompt-info"> <p>Another important thing to note here is the sparsity of $K$. Since $P_{sa}$ and $P_{sb}$ only sample a small fraction of the points in a $H \times W$ image, the resulting points sampled in $K$ will also only be a fraction of the total dimensionality of the matrix. Hence, we will use the <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html">CSR representation</a> to store K.</p> </blockquote> <p>Now armed with all of this info, we can finally get some insight into how we want to group and assemble the vector $v$.</p> <ol> <li>We want the elements in v ordered in such a way that slicing it into <strong>free</strong> and <strong>constrained</strong> points is relatively simple.</li> <li>We want to perform this grouping operation with a focus on storing indices.</li> </ol> <p>The second point is particularly important. Since CSR representation mainly focuses on the data present at a particular row and column index, storing the indices as we find unique elements and group them, allow us to optimize how the <code class="language-plaintext highlighter-rouge">row</code> and <code class="language-plaintext highlighter-rouge">col</code> vector are generated.</p> <h3 id="grouping-and-creating-the-vector-v">Grouping and creating the vector $v$</h3> <p>So in general, as far as I could tell, there were 2 ways to go about doing the first part. However do note that the <strong>logic for the first approach was annoyingly complicated and not worth it</strong>.</p> <ol> <li>Group the points in $V$ and within each group identify the unique elements and build the sparse matrix K accordingly.</li> <li>Independently group $P_{sa}$ and $P_{sb}$. Then identify the unique points overall and generate the sparse matrix.</li> </ol> <p>For the first approach we first combine $P_{sa}$ and $P_{sb}$ into a single vector. Then the combined vector (as a whole) is grouped into the independent sets. For illustrative reasons, four are used below, but in our case, we simply group into three ($F$,$H$ and $B$). When we perform the grouping operation, the order of the elements in the vector are changed. Hence, we store <code class="language-plaintext highlighter-rouge">Original Index</code>, which serves as a pointer to the original position of the <code class="language-plaintext highlighter-rouge">Grouped Non-Unique</code> vector in <code class="language-plaintext highlighter-rouge">{P_sa}+{P_sb}</code> (two sets concatenated not added). Once this is done <code class="language-plaintext highlighter-rouge">np.unique</code> is used to find the unique elements <strong>within each group</strong>.</p> <p><img src="Approach2.png" alt="grouping_approach_1"/> <em>The first approach illustrated. Here $F$, $G$, $B$ and $H$ represent arbitrary independent sets of points. Of course, in our application, it would only contain $F$,$H$ and $B$.</em></p> <p>This approach however, has a major flaw in the way the groups are formed. Since we combine $P_{sa}$ and $P_{sb}$ into a single vector, all points are repeated twice with two mappings in both <code class="language-plaintext highlighter-rouge">Inverse Index</code> as well as in <code class="language-plaintext highlighter-rouge">Original Index</code>. This ended up being a major hassle mapping back into the original vector (and subsequently $K_s$) and so was dropped.</p> <p>The second approach however, is far more straightforward. We find the unique elements for both $P_{sa}$ and $P_{sb}$ independently, but only use the unique vector generated from $P_sa$. This is essentially because ${P_{sa}} = {P_{sb}}$. Since they’re equal sets, we can simply search the elements to find the pointers from <code class="language-plaintext highlighter-rouge">np.unique(p_sb)</code> to <code class="language-plaintext highlighter-rouge">np.unique(p_sa)</code>.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">unique_vector</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">unique</span><span class="p">(</span><span class="n">p_sa</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">unique_vector</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">unique</span><span class="p">(</span><span class="n">p_sv</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">orig_indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">mat1</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">Ks</span><span class="p">[</span><span class="n">orig_indices</span><span class="p">]</span>
</code></pre></div></div> <p><img src="Approach3.png" alt="grouping_approach_1"/></p> <p class="text-justify">Once the unique points are found, we group it; storing the backward lookup. Once this is done, we populate $K$ using the corresponding values from $K_s$.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">group_unique_vectors</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">unique_vector</span><span class="p">,</span> <span class="n">search_space_list</span><span class="p">):</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="p">{</span>
        <span class="sh">'</span><span class="s">points</span><span class="sh">'</span><span class="p">:[],</span>
        <span class="sh">'</span><span class="s">row</span><span class="sh">'</span><span class="p">:[],</span>
        <span class="sh">'</span><span class="s">col</span><span class="sh">'</span><span class="p">:[],</span>
        <span class="sh">'</span><span class="s">data</span><span class="sh">'</span><span class="p">:[],</span>
        <span class="sh">'</span><span class="s">group_length</span><span class="sh">'</span><span class="p">:[]</span>
    <span class="p">}</span>
    <span class="n">stacked_groups</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">index_list_assembled</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">unqiue_vector</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># get the updated mappings for the unique indices
</span>    <span class="n">index_list_grouped</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">search_space_list</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="nf">inNd</span><span class="p">(</span><span class="n">unique_vector</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span>
        <span class="n">index_list_selected</span> <span class="o">=</span> <span class="n">index_list_assembled</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">index_list_grouped</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">index_list_selected</span><span class="p">)</span>
        <span class="n">groups</span><span class="p">[</span><span class="sh">'</span><span class="s">points</span><span class="sh">'</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">unique_vector</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
        <span class="n">groups</span><span class="p">[</span><span class="sh">'</span><span class="s">group_length</span><span class="sh">'</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">unique_vector</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>

    <span class="c1"># create lookup for new indices
</span>    <span class="n">index_list_grouped</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span><span class="n">index_list_grouped</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">index_list_grouped</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">mapping</span><span class="p">[</span><span class="n">index_list_grouped</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_list_assembled</span>

    <span class="c1"># update row and column information with updated indices
</span>    <span class="n">row</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">row</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">col</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">groups</span><span class="p">[</span><span class="sh">'</span><span class="s">row</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>
    <span class="n">groups</span><span class="p">[</span><span class="sh">'</span><span class="s">col</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span>
    <span class="n">groups</span><span class="p">[</span><span class="sh">'</span><span class="s">data</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="c1"># update stacked stuff
</span>    <span class="n">stacked_groups</span><span class="p">[</span><span class="sh">'</span><span class="s">stacked_points</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span><span class="n">groups</span><span class="p">[</span><span class="sh">'</span><span class="s">points</span><span class="sh">'</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">stacked_groups</span><span class="p">[</span><span class="sh">'</span><span class="s">stacked_row</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>
    <span class="n">stacked_groups</span><span class="p">[</span><span class="sh">'</span><span class="s">stacked_col</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span>
    <span class="n">stacked_groups</span><span class="p">[</span><span class="sh">'</span><span class="s">stacked_data</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
    <span class="n">stacked_groups</span><span class="p">[</span><span class="sh">'</span><span class="s">stacked_group_length</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="sh">'</span><span class="s">group_length</span><span class="sh">'</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">groups</span><span class="p">,</span> <span class="n">stacked_groups</span>
</code></pre></div></div> <p>Once the assembly has been completed, we also <strong>verify the process</strong> by testing for the following equality.</p> \[VKV^T = \sum_{s \in S} K_s ||P_{sa}-P_{sb}||^2\] <h2 id="solving-for-free-points">Solving for free points</h2> <p>Perhaps the easiest step in all of this is solving for the free points in the system. Once we know where we’ll move the constrained points to, our job is to solve for the new position of free points. We take the assembled matrix $vKv^T$ from above and minimize the energy in the system.</p> \[\begin{aligned}[b] \frac{\partial E}{\partial V} &amp;= \frac{1}{2}K \times V = 0 \\ K \times V &amp;= 0 \\ K_f \times F + K_c \times C &amp;= 0 \\ K_f \times F &amp;= -K_c \times C \end{aligned}\] <p>Now that we have the free point positions $F$ in the above format, we can use any solver to solve for the matrix equation of the form $Ax = b$. In python, a good way to do this is to use the cg solver that scipy offers.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">cg</span>
<span class="n">known_b</span> <span class="o">=</span> <span class="n">K_c</span><span class="o">@</span><span class="p">(</span><span class="n">C</span><span class="o">-</span><span class="n">C_init</span><span class="p">)</span>
<span class="n">unknown_a</span> <span class="o">=</span> <span class="n">K_f</span>

<span class="c1"># solve for x and y
</span><span class="n">x_solved</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="nf">cg</span><span class="p">(</span><span class="n">unknown_a</span><span class="p">,</span> <span class="o">-</span><span class="n">known_b</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="n">y_solved</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="nf">cg</span><span class="p">(</span><span class="n">unknown_a</span><span class="p">,</span> <span class="o">-</span><span class="n">known_b</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="n">out_points</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">stack</span><span class="p">([</span><span class="n">x_solved</span><span class="p">,</span> <span class="n">y_solved</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div> <blockquote class="prompt-info"> <p>Note that the <code class="language-plaintext highlighter-rouge">maxiter=200</code> argument was set because it worked well in my particular case. You might need to play around with that to find the right number of iterations to solve for.</p> </blockquote> <p>Now that this is done, we know where the free points have moved to. All that’s left is the barycentric interpolation to interpolate for the points we didn’t solve for.</p> <h2 id="interpolating-the-points-inside-the-triangle">Interpolating the points inside the triangle</h2> <p>Now that we’ve assembled the matrix and solved for the free points $F$. We come to the final part, interpolating the intermediate values. As explained before, we create the free and constrained point triangulation at time $t+1$. Then we move the constrained points $C$ to the position it was at at $t$ and ask the question, where did $F$ move? Obtaining this gives us a warpfield that points from $F^{t+1}$ to $F^{t}$, in essence telling us <strong>where</strong> to sample the pixel values for image $I^{t+1}$ from image $I^{t}$.</p> <p>This results in us having the solution <strong>only</strong> at the vertices of the initial triangulation. To interpolate the pixel color values for $I^{t+1}$ at points within each triangle, we perform a piece-wise linear interpolation using the point’s <a href="https://en.wikipedia.org/wiki/Barycentric_coordinate_system#:~:text=In%20geometry%2C%20a%20barycentric%20coordinate,dimensional%20space%2C%20etc.">barycentric coordinates</a>.</p> <p>To do this, we simply find the fractional distance between a random internal point to the vertices of the triangle. To understand this, let’s have a look at the system below. <img src="Barycentric_inter.png" alt="Barycentric Interpolation"/></p> <p>Basically, we define the fractions, $a_1$, $a_2$ and $a_3$ as the following ratios.</p> \[\begin{aligned}[b] a1 = \frac{\text{Area of }\Delta P_3QP_2}{\text{Area of }\Delta P_1P_2P_3} \\ a2 = \frac{\text{Area of }\Delta P_1QP_3}{\text{Area of }\Delta P_1P_2P_3} \\ a3 = \frac{\text{Area of }\Delta P_1QP_2}{\text{Area of }\Delta P_1P_2P_3} \\ \end{aligned}\] <p>And then, the barycentric coordinates relative to the vertices would be,</p> \[Q = a_1P_1+a_2P_2+a_3P_3\] <p>With this, we can interpolate the pointers on a similar way. At each of the points defined by $F$, we have a $1 \times 2$ pointer that points to a sampling pixel from the $I^t$. Hence using the above equation, we can compute the pointer the coordinates in the triangles in $I^{t+1}$ must point to.</p> <p>Another way, which I prefer for neatness is to use the displacement field instead of the pointer field. The displacement field is simply the difference in value at coordinate $(i,j)$ with $(i,j)$. In essence,</p> \[\Delta(WF) = I^{t+1}(i,j) - (i,j)\] <p>Then a similar interpolation operation as mentioned above can be used to compute all the values. After which to restore it to a pointer field we simply perform,</p> \[WF_{inter} = \Delta(WF) + (i,j)\] <p>One particular reason I prefer this way is because it’s much easier to visualize the displacements as opposed to the pointers (which tend to look like a smooth gradient if done correctly).</p> <table> <thead> <tr> <th style="text-align: center">$I_t$</th> <th style="text-align: center">Post-Interpolation I^{t+1}</th> </tr> </thead> <tbody> <tr> <td style="text-align: center"><img src="constrained_image_initial_red.png" alt="Original Image"/></td> <td style="text-align: center"><img src="warped_demo_image.png" alt="Warp Interpolation"/></td> </tr> </tbody> </table>]]></content><author><name></name></author><category term="Computer Graphics"/><category term="Simulations"/><category term="spring elements"/><category term="scipy"/><category term="opencv"/><category term="numpy"/><summary type="html"><![CDATA[Introduction In the era of deep learning and data-driven approaches to computer vision, there’s a certain beauty to classical computer vision techniques. This post is about one such idea.]]></summary></entry><entry><title type="html">Segmentation Of Heartbeat Sounds Using Shannon Energy Envelopes</title><link href="https://adithyaknarayan.github.io/blog/2018/Segmentation-Of-Heartbeat-Sounds-Using-Shannon-Energy-Envelopes/" rel="alternate" type="text/html" title="Segmentation Of Heartbeat Sounds Using Shannon Energy Envelopes"/><published>2018-09-27T00:00:00+00:00</published><updated>2018-09-27T00:00:00+00:00</updated><id>https://adithyaknarayan.github.io/blog/2018/Segmentation%20Of%20Heartbeat%20Sounds%20Using%20Shannon%20Energy%20Envelopes</id><content type="html" xml:base="https://adithyaknarayan.github.io/blog/2018/Segmentation-Of-Heartbeat-Sounds-Using-Shannon-Energy-Envelopes/"><![CDATA[<p>Data pre-processing is often a necessary step when using any signal, It allows us to enhance specific features, get rid of unnecessary ones and most importantly, it allows us to transform the input signal into a form which is easier for us to process.</p> <p>Today, I’ll be going over the steps that I took in pre-processing heartbeat audio data with the idea in mind that the data would ultimately be used by a Convolutional Neural Network to classify different heart sounds.</p> <p>As usual, the entirety of the code for this project, including the code for the other parts of the project, can be found over <a href="https://github.com/pavan-kalyan/heartbeat-audio-CNN">here</a>. If you’re curious about the data-set that was used, that can be found over <a href="http://www.peterjbentley.com/heartchallenge/">here</a>.</p> <h1 id="background">Background</h1> <p>The turbulence created in blood flow when a healthy heart function generates heart sounds. For a healthy adult, heart sounds typically involve two components: a S1 ‘lub’ sound followed by a S2 ‘dub’ sound. These are produced by the closing of the atrioventricular valves and the semi lunar valves respectively. The sounds made by a heart during normal function can be recorded to generate phonocardiograms. These phonocardiograms can then be analyzed to determine whether or not the heart is functioning properly. In this project, an attempt was made to classify various heart diseases based off of time-dependent patterns present within a phonocardiogram.</p> <h1 id="why-s1-and-s2-peak-detection">Why S1 and S2 Peak Detection?</h1> <p>As can be seen at the link provided, only about 179 files were provided overall. An interesting problem was that the number of files that was provided for each of the categories - artifact, murmur, extrahls and normal- was far too few to train a CNN reliably. Hence, if each individual heartbeat could be extracted, the CNN would have a greater number of data points to work with. Furthermore, the period and the frequency of a patient’s heartbeat cycle depends on their physical and physiological state[1]. Hence, it is possible for the network to misclassify a particular recording based off of the number of heartbeats recorded.</p> <p>To solve this, a method was necessary to isolate individual heartbeats from each audio file. While there may be several methods to achieve this, in this particular project, we chose to use the method of S1 and S2 peak isolation to identify a ‘lub-dub’ pair. Once this was done, the sample exactly midway between each S1 and S2 pair is found and stored in an array. Subsequently, the samples midway between these are found. This gives us a list of points which can be used to separate each S1 and S2 pair. </p> <p>While this sounds fairly easy on the face of it, we’re in a real pickle when it comes to detecting S-R peaks. While S-R peaks have amplitudes relatively larger than the electronic noise present in the signal, the presence of false peaks make it difficult to distinguish the true peaks from that false ones. To tackle this, I had to delve into the current literature present on the topic with one goal in mind; a method that is effective yet simple to implement. In effect I needed something that, despite only working under specific constraints, is able to isolate the S1 and S2 peaks with a great enough accuracy. Hence, I ended up using Shannon Energy Envelopes for peak isolation as outlined in [2].</p> <h1 id="s1-and-s2-peak-isolation-with-shannon-energy-envelope">S1 and S2 peak Isolation with Shannon Energy Envelope</h1> <p>To begin with, we load the heartbeat audio and normalize and the signal using the following normalization equation[1].</p> \[\begin{aligned} a[n] = \left (\frac {|f[n]|}{max_{i=1}^{N} |f[n]|} \right )^2 \end{aligned}\] <p>where a[n] is the normalized amplitude and f[n] is the input signal to the system.</p> <p float="left"> <img src="/normalized_signal.webp" width="100"/> </p> <table> <thead> <tr> <th style="text-align: center">Input Signal</th> <th style="text-align: center">Normalized Shannon Waveform</th> </tr> </thead> <tbody> <tr> <td style="text-align: center"><img src="normalized_signal.webp" alt="Normalized shannon"/></td> <td style="text-align: center"><img src="normalized_signal.webp" alt="Normalized shannon"/></td> </tr> </tbody> </table> <p>While it not necessarily typical to square the signal, it is a bit simpler to isolate S1 and S2 peaks of a heartbeat signal when we don’t have to work with negative amplitudes for a signal.</p> <p>Once the signal has been normalized, we begin to calculate the Shannon Energy of the signal. As is evident from their name, this method depends on the calculation of the energy of the signal. So before I get into calculating the Shannon Energy, I’ll briefly touch on the energy of a discrete signal and how it relates to the Shannon Energy of the same.</p> <p>In general, for a discrete signal, the energy of the signal, $E_s$, is given by,</p> \[\begin{aligned} SE = -|a[n]|log(a[n]) \end{aligned}\] <p>Subsequently, the Shannon Energy spectrum is computed using,</p> \[\begin{aligned} s[n] &amp;= -a^2[n]log(a^2[n]) \nonumber \\ s[n] &amp;= \frac{s[n] - \mu}{\sigma} \end{aligned}\] <p>As can be seen below, on computing the Shannon Energy the peaks associated with the S1 and S2 components of the heartbeat audio are more prominent compared to the amplitude to other parts of the signal.</p> <p><img src="shannon_energy.png" alt="Normalized shannon"/></p> <p>While it looks like the above plot is where we stop and isolate the positions of the peaks, further steps are in fact required. Due to the presence of numerous smaller peaks in the vicinity of the true peak, even if we compute local maximas over say every 2,500 samples, we would get a number of false peaks nearby the true peak. To overcome this, we smooth the signal before peak isolation.</p> <h1 id="envelopes-and-segmentation">Envelopes And Segmentation</h1> <p>In general, a signal envelope can be defined as a smooth curve connecting all of the extremes of an oscillating input signal[4]. Natively, MatLab offers a variety of enveloping methods. This ranges from envelopes computed using Hilbert Transforms to RMS enveloping. Details of the same can be seen on the official MatLab documentation page over here.</p> <p>In this particular case, peak envelopes were used only taking into account local maxima a thousand samples apart. While it is possible to manually implement this using the relevant equations, in this case, for simplicity, MatLab’s inbuilt ‘envelope()’ function was used. On enveloping the Shannon spectrum of the signal, we observe the following.</p> <p><img src="peak_envelopes.png" alt="Normalized shannon"/></p> <p>From here, the positions of the local maximas were isolated and saved into an array. Additionally the sample positions associated with the corresponding maxima were determined. In simpler words, the time at which these peaks occurred were determined. These local maximas superimposed over the Shannon Energy Spectrum produces,</p> <p><img src="marked_peaks.png" alt="Normalized shannon"/></p> <p>Once these were figured out, these points were superimposed on the original normalized signal to test as to whether it was a reasonable estimate of the S1 and S2 peaks of the heartbeat audio.</p> <p><img src="marked_peaks_normalized.png" alt="Normalized shannon"/></p> <p>As can be seen, while this method is not entirely accurate when determining the position of the S1 peaks. However, this is not too much of a problem since we only need an estimate of the positions of the S1 and S2 peaks for the segmentation part.</p> <p>For segmenting the signal, the midpoint between every S2 and the following S1 peak is calculated. Then, logically, it follows that a single heartbeat sound is from one midpoint to the next. The original audio was then subdivided into smaller files each containing a single heartbeat sound.</p> <h1 id="spectrogram-generation">Spectrogram Generation</h1> <p>Once individual heartbeats were isolated, a method of method of data representation was required such that it satisfied two conditions. One was that it should retain information regarding its time dependence. This meant that it was important that the CNN took into account the variation of the signal over time when making a prediction. The second condition was that the data should be in a form that can be fed into a CNN. Most suitably, the data should be represented in the form of an image. As a consequence of these constraints, spectrograms were generated from the data before being being used to train the CNN.</p> <p>So to begin with, what are spectrograms? Essentially, spectrograms are a visual representation of the change in the frequency components of a signal over time. Essentially, you take snapshots across small intervals in the signal and compute the frequencies present in the signal for that duration. Then you represent this spectrum as a heat map. More formally, the Short Time Fourier Transforms are computed for the specified windows and the magnitude is represented as a heat map.</p> <p>Here, the Matlab function ‘spectrogram()’ was used to compute the spectrogram of each individual heartbeat. Internally, this function computes the STFT of the signal and represents it in the form of an image as seen below. Details on the usage and the nature of the output can be read <a href="https://in.mathworks.com/help/signal/ref/spectrogram.html">here</a>. The result of this is shown in the figure below.</p> <h1 id="references">References</h1> <ol> <li> <p>M. Yochum, C. Renaud, and S. Jacquir, “Automatic detection of P, QRS and T patterns in 12 leads ECG signal based on CWT,” Biomedical Signal Processing and Control, vol. 25, pp. 46–53, 2016</p> </li> <li> <p>Hamed Beyramienanlou and Nasser Lotfivand, “Shannon’s Energy Based Algorithm in ECG Signal Processing,” Computational and Mathematical Methods in Medicine, vol. 2017, Article ID 8081361, 16 pages, 2017. https://doi.org/10.1155/2017/8081361.</p> </li> <li> <p>M. S. Manikandan and K. P. Soman, “A novel method for detecting R-peaks in electrocardiogram (ECG) signal,” Biomedical Signal Processing and Control, vol. 7, no. 2, pp. 118–128, 2012.</p> </li> <li> <p>C. Richard Johnson, Jr; William A. Sethares; Andrew G. Klein (2011). “Figure C.1: The envelope of a function outlines its extremes in a smooth manner”. Software Receiver Design: Build Your Own Digital Communication System in Five Easy Steps. Cambridge University Press. p. 417.</p> </li> </ol>]]></content><author><name></name></author><category term="Computer Vision"/><category term="Signals Processing"/><category term="opencv"/><category term="matlab"/><category term="numpy"/><summary type="html"><![CDATA[Data pre-processing is often a necessary step when using any signal, It allows us to enhance specific features, get rid of unnecessary ones and most importantly, it allows us to transform the input signal into a form which is easier for us to process.]]></summary></entry><entry><title type="html">Object Tracking Bot With IP Webcam and OpenCV</title><link href="https://adithyaknarayan.github.io/blog/2018/Object-Tracking-Bot-With-IP-Webcam-and-OpenCV/" rel="alternate" type="text/html" title="Object Tracking Bot With IP Webcam and OpenCV"/><published>2018-01-01T21:01:00+00:00</published><updated>2018-01-01T21:01:00+00:00</updated><id>https://adithyaknarayan.github.io/blog/2018/Object%20Tracking%20Bot%20With%20IP%20Webcam%20and%20OpenCV</id><content type="html" xml:base="https://adithyaknarayan.github.io/blog/2018/Object-Tracking-Bot-With-IP-Webcam-and-OpenCV/"><![CDATA[<h1 id="introduction">Introduction</h1> <p>So, recently, I’ve been working on a 4-wheeled bot capable following a uniformly colored, regular object. Given that I’m still trying to figure out the nature of this blog, I’ve decided to go ahead and summarize the process of me trying to build this.  For the purpose of clarity, I’ve split the post into the three larger domains of work. Also, you can find the entire work on my github page.</p> <h1 id="tracking">Tracking</h1> <p>To begin with, I needed some way to send video data of what the bot was seeing to the computer so that it could be processed using OpenCV. Given that I didn’t have any small camera lying around, I decided to use my phone. In particular, there’s a pretty convenient Android application called “IP Webcam” with which you can stream video to a local IP address. It also has pretty nifty additional features like remotely turning on your phone camera’s light, enabling night vision, motion detection, etc.</p> <p>For this particular project I’ve used a form of colour tracking to track the object in the frame. To do this, I first stored each frame of the video stream in a variable called ‘cap’.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">cv2</span> <span class="k">as</span> <span class="n">cv</span> 
<span class="n">cap</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="nc">VideoCapture</span><span class="p">(</span><span class="sh">'</span><span class="s">enter the url here</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div> <p>Then, using the functions ‘GaussianBlur’ and ‘cvtColor’ the frames were blurred and converted from the BRG scale to the HSV scale. Additionally, ‘inRange’ was used to isolate the colour blue from the frames.Subsequently, the images were eroded and dilated using in-built function available in OpenCV-Python. In general, this makes it easier to process the edges and also reduces the overall noise in each frame.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">blurred_frame</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="nc">GaussianBlur</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="nf">inRange</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="n">lower_val</span><span class="p">,</span><span class="n">upper_val</span><span class="p">)</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="nf">erode</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="nf">dilate</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span><span class="n">iterations</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div> <p>With all of this done, we obtain a thresholded image where the colour blue has been isolated. However, this is not enough. For the robot to be able to follow the coloured object, the edges as well as the center of the object need to be identified. To do this, contours are used. By using the function ‘findContours’, a curve joining all continuous points on the thresholded frame is drawn. Additionally, ‘moments’ is used to find its center.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">channels</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">shape</span>
<span class="n">iX</span> <span class="o">=</span> <span class="n">width</span><span class="o">/</span><span class="mi">2</span>
<span class="n">iY</span> <span class="o">=</span> <span class="n">height</span><span class="o">/</span><span class="mi">2</span>
 <span class="n">_</span><span class="p">,</span><span class="n">contours</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="nf">findContours</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="n">cv</span><span class="p">.</span><span class="n">RETR_TREE</span><span class="p">,</span><span class="n">cv</span><span class="p">.</span><span class="n">CHAIN_APPROX_SIMPLE</span><span class="p">)</span>
<span class="k">if</span> <span class="n">cv</span><span class="p">.</span><span class="nf">contourArea</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
       <span class="n">M</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="nf">moments</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
       <span class="n">cX</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="sh">"</span><span class="s">m10</span><span class="sh">"</span><span class="p">]</span><span class="o">/</span><span class="n">M</span><span class="p">[</span><span class="sh">"</span><span class="s">m00</span><span class="sh">"</span><span class="p">])</span>
       <span class="n">cY</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="sh">"</span><span class="s">m01</span><span class="sh">"</span><span class="p">]</span><span class="o">/</span><span class="n">M</span><span class="p">[</span><span class="sh">"</span><span class="s">m00</span><span class="sh">"</span><span class="p">])</span>
       <span class="n">cv</span><span class="p">.</span><span class="nf">drawContours</span><span class="p">(</span><span class="n">frame</span><span class="p">,[</span><span class="n">c</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
       <span class="n">cv</span><span class="p">.</span><span class="nf">circle</span><span class="p">(</span><span class="n">frame</span><span class="p">,(</span><span class="n">cX</span><span class="p">,</span><span class="n">cY</span><span class="p">),</span><span class="mi">7</span><span class="p">,(</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
       <span class="n">cv</span><span class="p">.</span><span class="nf">putText</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="sh">"</span><span class="s">center</span><span class="sh">"</span><span class="p">,</span> <span class="p">(</span><span class="n">cX</span> <span class="o">-</span> <span class="mi">20</span><span class="p">,</span> <span class="n">cY</span> <span class="o">-</span><span class="mi">20</span><span class="p">),</span><span class="n">cv</span><span class="p">.</span><span class="n">FONT_HERSHEY_SIMPLEX</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
       <span class="n">res</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="nf">bitwise_and</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span><span class="n">frame</span><span class="p">,</span><span class="n">mask</span> <span class="o">=</span><span class="n">mask</span><span class="p">)</span>
</code></pre></div></div> <p>As can be seen above, I’ve also saved the co-ordinates of the center of each frame. To explain why that’s been done, I have to explain first how I plan to track the object. Essentially, my plan was to treat the center of the image as the origin and find the position of $cX$ and $cY$ relative to this origin.</p> <p><img src="vector_diagram.png" alt="Vector Diagram Figure"/> <em>Determining the position vector.</em></p> <p>On doing so, we obtain a vector $\vec{P}$ which points from $(iX, iY)$ to $(cX,cY)$</p> \[\begin{aligned} \vec{P} = \begin{pmatrix} cY-iY\\cX-iX \end{pmatrix} \end{aligned}\] <p>From the components of this vector, we can draw a conclusion on whether the bot should turn clockwise or counter-clockwise. If $cX-iX &gt; 0$, then the bot should turn clockwise whereas if $cX-iX &lt; 0$ the bot should turn counter clockwise. By doing so, the bot constantly tries to align the center of the object with the y-axis of the frame.</p> <p>For the time being, the bot is unable to determine the object’s distance from the camera. However, this can be implemented by determining some scale factor between image size as seen by the camera and that of the object in real life. Then, the distance can be approximated by calcuating the focal length of the camera.</p> <h1 id="bluetooth-connector">Bluetooth Connector</h1> <p>Now that the bot knows where the object is and how it should move to centralize the image, a method is required to send this information to the Arduino. For this, the HC-05 bluetooth module was used using the wiring configuration shown here.</p> <p>Linux natively has no method for serial communication using bluetooth. However, by downloading something like Blueman, which is what was used in this case, you can allow for serial communication. Similarly, modules may be downloaded for python which allows you to write code for the communication part.</p> <p>For starters, the ‘bluetooth’ module is imported and nearby bluetooth devices are scanned for. Once the device with the name HC-05 is found and connected to, communication can begin. Additionally, since this python module uses sockets for communication, a socket is set up using the RFCOMM protocol.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">target_name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">HC-05</span><span class="sh">"</span>
<span class="n">target_address</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">sock</span> <span class="o">=</span> <span class="n">bluetooth</span><span class="p">.</span><span class="nc">BluetoothSocket</span><span class="p">(</span><span class="n">bluetooth</span><span class="p">.</span><span class="n">RFCOMM</span><span class="p">)</span>
<span class="n">port</span> <span class="o">=</span> <span class="mi">1</span>
 
<span class="k">print</span> <span class="sh">"</span><span class="s">Searching for the HC-05 module...</span><span class="sh">"</span>
<span class="n">nearby_devices</span> <span class="o">=</span> <span class="n">bluetooth</span><span class="p">.</span><span class="nf">discover_devices</span><span class="p">()</span>
 
<span class="k">for</span> <span class="n">baddr</span> <span class="ow">in</span> <span class="n">nearby_devices</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">target_name</span> <span class="o">==</span> <span class="n">bluetooth</span><span class="p">.</span><span class="nf">lookup_name</span><span class="p">(</span><span class="n">baddr</span><span class="p">):</span>
        <span class="n">target_address</span> <span class="o">=</span> <span class="n">baddr</span>
        <span class="k">break</span>
 
<span class="k">if</span> <span class="n">target_address</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="k">print</span> <span class="sh">"</span><span class="s">Done!</span><span class="sh">"</span>
    <span class="k">print</span> <span class="sh">"</span><span class="s">HC-05 found at the address</span><span class="sh">"</span><span class="p">,</span><span class="n">target_address</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="nf">raw_input</span><span class="p">(</span><span class="sh">"</span><span class="s">Would you like to connect to it?[y/n]</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ans</span> <span class="o">==</span> <span class="sh">'</span><span class="s">y</span><span class="sh">'</span><span class="p">:</span>
        <span class="n">sock</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">target_address</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="sh">"</span><span class="s">Terminating...</span><span class="sh">"</span>
        <span class="nf">exit</span><span class="p">()</span>
 
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span> <span class="sh">"</span><span class="s">No bluetooth device found nearby. Please try again later</span><span class="sh">"</span>
    <span class="nf">exit</span><span class="p">()</span>
</code></pre></div></div> <p>For the simplicity, numbers are sent through the port to the Arduino instead of characters. Additionally, a small clearance of 10 units has been implemented. This is because, if one were to set ‘0’ as the only point where the bot stops, the bot would jitter a lot when the center of the object tries to align with the axis of the frame.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dX</span> <span class="o">=</span> <span class="n">cX</span><span class="o">-</span><span class="n">iX</span>
<span class="n">dY</span> <span class="o">=</span> <span class="n">cY</span><span class="o">-</span><span class="n">iY</span>
 
<span class="k">if</span> <span class="n">dX</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
   <span class="c1">#'1' is to turn cloackwise
</span>   <span class="k">print</span> <span class="sh">"</span><span class="s">Bot shoudld turn clockwise</span><span class="sh">"</span>
   <span class="n">sock</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span><span class="p">)</span>
 
<span class="k">elif</span> <span class="n">dX</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">10</span><span class="p">:</span>
   <span class="c1">#'AC' is to turn anti-clockwise
</span>   <span class="k">print</span> <span class="sh">"</span><span class="s">Bot should turn conter-clockwise</span><span class="sh">"</span>
   <span class="n">sock</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="sh">'</span><span class="s">2</span><span class="sh">'</span><span class="p">)</span>
 
 <span class="k">elif</span> <span class="n">dX</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">):</span>
   <span class="c1">#0 is to stop turning
</span>   <span class="k">print</span> <span class="sh">"</span><span class="s">Bot should stop</span><span class="sh">"</span>
   <span class="n">sock</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="sh">'</span><span class="s">0</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div> <h1 id="motor-control-and-hardware">Motor Control and Hardware</h1> <p>The hardware part of this project was fairly simple. It involved:</p> <ol> <li>x2 custom circuits(one for the LCD display and the other for the motors)</li> <li>x4 plastic gear-box motors</li> <li>x1 metal chassis bought here</li> <li>x1 Arduino Mega</li> <li>x1 HC-05 bluetooth module</li> <li>x1 LCD dislpay</li> <li>Perf-board for interfacing the Arduino with the LCD display.</li> </ol> <p>The first thing to be set up was the circuit that would be responsible for running four motors in parallel. Generally, one L293D IC can control the direction and speed of two motors. Hence, to be able to run four motors, two L293D IC’s were used together in the configuration shown below. The labels show the digital pins on the Arduino to which the driver’s were connected to.</p> <p><img src="motor_driver.png" alt="Motor Driver Figure"/> <em>Pin connections for the drivers</em></p> <p>Once the connections had been made, the Arduino had to be programmed to accept the information received from the HC-05 module via Serial3. Again, the code for this can be seen on the github page mentioned at the top of the page.</p> <p>For the LCD display, I used a perf board to wire out the circuit shown over here. This is pretty much standard for the Arduino. Using this alongside the LiquidCrystal library available for the Arduino IDE, the LCD display was set up to display the direction that the bot is meant to turn to return to the mean position.</p> <h1 id="final-thoughts">Final Thoughts</h1> <p>The bot works surprisingly well given that it was slapped together kinda haphazardly. To be completely honest, the motors that I’ve used for this project are pretty bad and don’t offer enough torque for turning slowly. This makes things kinda messy when you move the object around in the bots field of view too quickly. Additionally, the way the bot corrects its positions is kinda janky at the moment.</p>]]></content><author><name></name></author><category term="Computer Vision"/><category term="OpenCV"/><category term="opencv"/><category term="numpy"/><summary type="html"><![CDATA[Introduction So, recently, I’ve been working on a 4-wheeled bot capable following a uniformly colored, regular object. Given that I’m still trying to figure out the nature of this blog, I’ve decided to go ahead and summarize the process of me trying to build this.  For the purpose of clarity, I’ve split the post into the three larger domains of work. Also, you can find the entire work on my github page.]]></summary></entry></feed>